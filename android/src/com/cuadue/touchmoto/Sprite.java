package com.cuadue.touchmoto;import android.graphics.Canvas;import android.graphics.drawable.Drawable;import java.lang.Math;class Point {    public float x = 0, y = 0;    public void add(Point other){        this.x += other.x;        this.y += other.y;    }        public void subtract(Point other){        this.x -= other.x;        this.y -= other.y;    }        public void add(float mag, float angle){        this.x += mag * Math.cos(angle);        this.y += mag * Math.sin(angle);    }}class Sprite {    private Drawable image;    public boolean visible = true;    public float x = 0, y = 0;    public int width = 30, height = 30;    public double angle;        public Sprite(Drawable d){    	image = d;    }            /* Always draws the entire bitmap image */     public void draw(Canvas canvas){        if(!visible) return;        canvas.save();        try{            canvas.translate((int)(x), (int)(y));	        canvas.rotate((float)(angle * 180f / Math.PI + 90f));	        canvas.translate((int)(- 0.5 * width), (int)(- 0.5 * height));	        image.setBounds(0, 0, width, height);	        image.draw(canvas);        }         finally{        	canvas.restore();        }    }        public boolean collidesWith(Sprite other){        return x >= other.x - other.width/2        	&& x <= other.x + other.width/2        	&& y >= other.y - other.height/2        	&& y <= other.y + other.height/2;    }        public void update(double dt){}}class Target extends Sprite{	public Target(Drawable d){		super(d);	}}class Rider extends Sprite{	public Target target;    public double velocity = 0;    public static final double brake = 500, accel = 200;    public static final double maxSpeed = 500, ft = 20000, mass = 200;    public int psi_sign;    	Rider(Drawable d){		super(d);	}        private double normAngle(double a){        if(a > Math.PI) a -= 2 * Math.PI;        if(a < -Math.PI) a += 2 * Math.PI;        return a;    }        public double turningRadius(){        if(!target.visible)            return 1e12;        double a0 = target.x - x, b0 = target.y - y;        double mag = Math.hypot(a0, b0); //mag: distance between Bike and it's target        double psi = normAngle(Math.atan2(b0, a0) - angle); //psi: angle of target relative to Bike's path of travel        if(psi > 0)            psi_sign = 1;        else            psi_sign = -1;                if(Math.abs(psi) > Math.PI/2f){            //i don't know why but sometimes this distance comes out negative... probably something to do with sin < 0 being negative            //take note, future scholars. The above is "dry humor"            double tmp = Math.abs(mag * Math.sin(psi - psi_sign * Math.PI/2f));            target.x += tmp * Math.cos(angle);            target.y += tmp * Math.sin(angle);                        psi = psi_sign * Math.PI/2f;            //the target is now parallel with path of travel at 90deg angle to the path of travel            a0 = target.x - x;            b0 = target.y - y;            mag = Math.hypot(a0, b0);        }                double a = mag * Math.sin(psi);        double b = mag * Math.cos(psi);        if(Math.abs(a) > 1e-12)            return Math.abs((a*a + b*b) / (2.0*a));        else            return 1e12;    }        @Override    public void update(double dt){        double r = turningRadius();            double r_min = mass * velocity * velocity / ft;        double v_max = Math.sqrt(r * ft/mass);                if(r < r_min && target.visible){            //brake            velocity = Math.max(0, velocity - brake * dt);            //slow_dist = 0.5 * ((self.speed - v_max) / self.brake) * (self.speed + v_max)            //pygame.draw.line(background, (127,0,0), (self.x, self.y), (self.x + cos(self.angle)*slow_dist,self.y + sin(self.angle)*slow_dist), 10)            r = 1e12;        }        else{            //accelerate            // Important to keep v_max * 0.98 because otherwise, the bike is really close to over accelerating with random fluctuations            // This is a little messy, but i think i understand the behavior if not the best solution.            velocity = Math.min(Math.min(velocity + accel * dt, maxSpeed), v_max * 0.98);        }                double l = dt * velocity;        if(target.visible && Math.abs(r) < 1e9){            // phi: angle of rotation to travel distance l over circle with radius r            double phi = l / r;            angle = normAngle(angle + (phi * psi_sign));                        // c: the chord with angle phi through circle with radius r. extremely close to l for small values of l            double c = 2f * r * Math.sin(phi/2.0);            // fabs(c-l) is typically less than 1e-5 pixels            x += c * Math.cos(phi + angle);            y += c * Math.sin(phi + angle);                        /*            // the remainder of this block is debug            // find the center of the turning circle            tmp = self.angle + (self.psi_sign * pi/2.0)            debugx = int(self.x + r * cos(tmp))            debugy = int(self.y + r * sin(tmp))                        // the path-of-travel circle            if(r < 1000 and r > 0):                pygame.draw.circle(background, (0,0,0), (debugx, debugy), int(r), 1)                pygame.draw.circle(background, (0,0,0), (debugx, debugy), 2, 0)            pygame.draw.line(background, (0,0,0), self.rect.center, (self.x + cos(self.angle)*100,self.y + sin(self.angle)*100), 1)            */        }        else{            x += l * Math.cos(angle);            y += l * Math.sin(angle);        }                if(collidesWith(target)){            target.visible = false;        }    }}